# -*- coding: utf-8 -*-
"""MOBIO

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/fishenzone/Projects/blob/main/projects/test_tasks/Mobio/mobio.ipynb
"""

from google.colab import drive
drive.mount('/content/drive')

"""## Task_1"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import csv
import sqlite3
from IPython.core.interactiveshell import InteractiveShell  
InteractiveShell.ast_node_interactivity = "all"
plt.style.use('dark_background')

adv = pd.read_csv('/content/drive/MyDrive/advertiser.csv')
stats = pd.read_csv('/content/drive/MyDrive/stats.csv')

print('Advertiser data')
adv.head()
print('\nStats data')
stats.head()

relevant_id = stats.advertiser_fk.unique()
print(f'List of advertisers id: {sorted(relevant_id)}\n\
Number of unique advertisers: {stats.advertiser_fk.nunique()}')

df_merge = pd.merge(adv, stats, how='inner', left_on=['id'], right_on=['advertiser_fk'])
df = df_merge.groupby(by=['date', 'name']).sum()[['cost', 'installs']].reset_index()
df['cpi'] = df.cost/df.installs
df.date = pd.to_datetime(df.date, infer_datetime_format=True).dt.day
df.head()

def plot(df, cost='cost'):
  fig, axs = plt.subplots(2,2, figsize=(22, 12))
  fig.subplots_adjust(hspace =.35, wspace=.2)
  axs = axs.ravel()
  
  for i, x in enumerate(df.name.unique()):
    df_id = df[df.name==x]
    axs[i].tick_params(labelrotation=333)
    axs[i].set_xlabel('Day')

    if cost == 'cost': 
      axs[i].plot(df_id.date.values, df_id.cost.values)
      axs[i].set_ylabel('Cost')
      axs[i].set_title(f'График расходования бюджета по дням по рекламодателю: {x}')
    
    elif cost == 'cpi':
      axs[i].plot(df_id.date.values, df_id.cpi.values)
      axs[i].set_ylabel('CPI')
      axs[i].set_title(f'График  CPI по дням по рекламодателю: {x}')
    
    else: print('This feature is not available yet, but we\'re trying our best to deploy it!')

plot(df)
plot(df, 'cpi')

print('Таблица расходования общего бюджета по всем рекламодателям по дням:\n')
# df_merge.groupby(by=['date', 'name']).sum()['cost'].reset_index()
# "по всем рекламодателям по дням" - т.е. в сумме? Здесь не совсем понял, поэтому 2 варианта(один закомментирован).
df_merge.groupby(by=['date']).sum()['cost'].reset_index()

"""## Task_2
### Сначала создадим 2 таблицы и потом сделаем запрос.
"""

connection = sqlite3.connect('task_2.db')
cursor = connection.cursor()
create_table = '''create table adv(
  id int, 
  advertiser_id  int, 
  is_active bool, 
  created_at varchar,
  updated_at varchar,
  name varchar);
'''
cursor.execute(create_table)
file = open('/content/drive/MyDrive/advertiser.csv')
contents = csv.reader(file)
insert_records = "INSERT INTO adv(id, advertiser_id, is_active, created_at, updated_at, name) VALUES(?, ?, ?, ?, ?, ?)"
cursor.executemany(insert_records, contents)
select_all = "SELECT * FROM adv"
rows = cursor.execute(select_all).fetchall()
connection.commit()
connection.close()

for row in rows[:5]:
    print(row)

connection = sqlite3.connect('task_2.db')
cursor = connection.cursor()
create_table = '''create table stats(
  id int, 
  advertiser_fk int, 
  campaign_id int, 
  adgroup_id int, 
  ad_id int, 
  impressions int, 
  clicks int, 
  installs int, 
  date date, 
  cost REAL);
'''
cursor.execute(create_table)
file = open('/content/drive/MyDrive/stats.csv')
contents = csv.reader(file)
insert_records = "INSERT INTO stats(id, advertiser_fk, campaign_id, adgroup_id, ad_id, impressions, clicks, installs, date, cost) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
cursor.executemany(insert_records, contents)
select_all = "SELECT * FROM stats"
rows = cursor.execute(select_all).fetchall()
connection.commit()
connection.close()

for row in rows[:5]:
    print(row)

"""### SQL запрос, позволяющий сделать таблицу, в которой будут показы, клики, инсталлы, CPI, расход по дням по каждому рекламодателю.

"""

sql_query = '''
SELECT 
  stats.date as date,
  adv.name as name,
  sum(stats.impressions) as impressions, 
  sum(stats.clicks) as clicks, 
  sum(stats.installs) as installs, 
  round(sum(stats.cost)/ sum(stats.installs), 2) as CPI,
  round(sum(cost), 2) as cost
FROM 
  stats 
  INNER JOIN adv ON stats.advertiser_fk = adv.id 
group by 
  stats.date, 
  adv.name
order by
  date, name;
'''

connection = sqlite3.connect('task_2.db')
df_sql = pd.read_sql_query(sql_query, connection)
connection.close()
df_sql.head()

"""### Another way

"""

connection = sqlite3.connect('task_2.db')
cursor = connection.cursor()
cursor.execute(sql_query)
result = cursor.fetchall()
for row in result[:10]:
    print(row)
connection.close()

column_names = ['date', 'name', 'impressions', 'clicks', 'installs', 'CPI', 'cost']
pd.DataFrame(result, columns=column_names).head()

"""## Task_3
### Я загуглил формулу расчета тротуара:
### $b_p = \frac{N*b_n}{P}+b_B+b_Д$,

где N - интенсивность пешеходного движения, пеш/ч;

P - расчетная пропускная способность полосы пешеходного движения, пеш./ч;

bn - ширина полосы пешеходного движения( для пешеходных переходов и лестниц - 1 м, для прочих пешеходных путей - 0,75 м );

bв - полоса безопасности, составляющая 0,6 м в сторону проезжей части или велодорожки и 0,3 м в сторону застройки (наличие зеленых защитных насаждений не учитывается);

+bд - дополнительная полоса тротуара от 0,5 до 1,2 м при наличии в его пределах мачт освещения, опор контактной сети и т.п.

Полученная по первому слагаемому формулы величина ходовой части ширины тротуара должна быть округлена до ближайшего значения, кратного 0,75м.

"""

class Size:
  def __init__(self, N, P, b_n, b_B, b_D):
    self.N = N
    self.P = P
    self.b_n = b_n
    self.b_B = b_B
    self.b_D = b_D
    self.b_p = (N * b_n / P) + b_B + b_D
  
  def calc(self, base=0.75):
    return base * round(self.b_p/base)

pavement_width = Size(550, 900, 1, 0.6, 0.5)
print(f'Pavement Width: {pavement_width.calc()} meters.')